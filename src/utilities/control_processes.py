"""!
Contains all functions that work directly with the control elements.
There should be a minimal amount of computation done in these functions.
"""


import datetime
import time
import sys


def watering_process(msg, controls, queue, db):
    """!
    Based on the calculated level it is provided, the watering_process
    will determine how long it needs to water for, then it will
    actuate the pump for the appropriate amount of time.
    @param msg: The control message generated by the watering algorithm
    @param controls: Access to the control devices
    @param queue: Queue to relay to the main process
    @param db: Copy of the master database
    """

    # Determine the required watering time
    measured_level = msg[1] # NOTE: Currenly unused
    calculated_level = msg[3]
    moisture_low = db["Moisture_Low"]
    moisture_high = db["Moisture_High"]
    lh = abs(moisture_low-moisture_high)
    max_flow = 500  # [mL]
    if calculated_level > moisture_high:
        flow = 0
    elif calculated_level <= moisture_high:
        flow = (max_flow/(2*lh))*calculated_level + 50
        if flow > max_flow:
            flow = max_flow
    flow_per_second = 0.905  # [mL/s]
    pump_time = int(flow/flow_per_second)

    # Operate the pump
    controls['pump'].turn_on()
    print("Beginning pump for", pump_time, "seconds.")
    for _ in range(pump_time):
        if not queue.empty():
            msg = queue.get()
            print("Pump is being interrupted by manual override.")
            controls['pump'].turn_off()
            sys.exit(0)
        time.sleep(1)
    controls['pump'].turn_off()

    # Relay that it is finished
    queue.put("Finished pumping for " + str(pump_time) + "s.")

    # Terminate the process
    sys.exit(0)


def fan_process(msg, controls, queue):
    """!
    The fan process reads the control message and controls the fan accordingly.
    If flag is HIGH --> turn ON the fan
    If flag is LOW --> turn OFF the fan

    @param msg: The control message generated by the environment algorithm.
    @param controls: Access to the control elements.
    @param queue: Communication channel to the main process.
    """

    # Read the message for the fan flag and respond accordingly
    if msg[1]['temperature']['flag'] == "HIGH":
        controls['fan'].turn_on()
        queue.put("Fan turned ON")
    elif msg[1]['temperature']['flag'] == "LOW":
        controls['fan'].turn_off()
        queue.put("Fan turned OFF")

    # Terminate the process
    sys.exit(0)


def lighting_process(db, controls):
    """!
    The lighting process sets the RGB and UV LEDs to whatever
    light values are specified in the config file (stored in database).

    The lighting process is so lightweight that is does not
    run as a seperate process. Instead it runs in series with the main process.

    @param db: The master database.
    @param controls: Access to all the control elements.
    """
    try:
        # Get the current hour & the corresponding RGB data
        hour = str(datetime.datetime.now().hour)
        rgb_data = db['RGB_data'][hour]
        red = rgb_data['R']
        green = rgb_data['G']
        blue = rgb_data['B']

        # Check for manual override on the RGB LED Strip
        if not db['Manual Overrides']['RGB LED']:
            # Adjust the RGB Accordingly and update the status
            controls['RGB LED'].adjust_color(red_content=red, green_content=green, blue_content=blue)
            db['RGB LED Status'] = [red, green, blue]

        # Check for manual override on the UV LED Strip
        if not db['Manual Overrides']['UV LED']:
            # Get the UV light data for the current hour
            if db['UV_data'][hour]:
                controls['UV LED'].turn_on()
                db['UV LED Status'] = "ON"
            else:
                controls['UV LED'].turn_off()
                db['UV LED Status'] = "OFF"
    except Exception as err:
        return err
    return 0
